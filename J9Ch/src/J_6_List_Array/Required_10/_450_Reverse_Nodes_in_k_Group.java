package J_6_List_Array.Required_10;

/** 450 Reverse Nodes in k-Group
 * Hard

 * Created by tianhuizhu on 6/28/17.
 */
public class _450_Reverse_Nodes_in_k_Group {
    public class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

// version 1:
    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) { val = x; }
     * }
     */
    public class Solution1 {
        /**
         * @param head a ListNode
         * @param k an integer
         * @return a ListNode
         */
        public ListNode reverseKGroup(ListNode head, int k) {
            ListNode dummy = new ListNode(0);
            dummy.next = head;

            head = dummy;
            while (true) {
                head = reverseK(head, k);
                if (head == null) {
                    break;
                }
            }

            return dummy.next;
        }

        // head -> n1 -> n2 ... nk -> nk+1
        // =>
        // head -> nk -> nk-1 .. n1 -> nk+1
        // return n1
        public ListNode reverseK(ListNode head, int k) {
            ListNode nk = head;
            for (int i = 0; i < k; i++) {
                if (nk == null) {
                    return null;
                }
                nk = nk.next;
            }

            if (nk == null) {
                return null;
            }

            // reverse
            ListNode n1 = head.next;
            ListNode nkplus = nk.next;

            ListNode prev = null;
            ListNode curt = n1;
            while (curt != nkplus) {
                ListNode temp = curt.next;
                curt.next = prev;
                prev = curt;
                curt = temp;
            }

            // connect
            head.next = nk;
            n1.next = nkplus;
            return n1;
        }
    }

// version 2:
    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) { val = x; }
     * }
     */
    public class Solution2 {
        /**
         * @param head a ListNode
         * @param k an integer
         * @return a ListNode
         */
        public ListNode reverseKGroup(ListNode head, int k) {
            if (head == null || k <= 1) {
                return head;
            }

            ListNode dummy = new ListNode(0);
            dummy.next = head;

            head = dummy;
            while (head.next != null) {
                head = reverseNextK(head, k);
            }

            return dummy.next;
        }

        // reverse head->n1->..->nk->next..
        // to head->nk->..->n1->next..
        // return n1
        private ListNode reverseNextK(ListNode head, int k) {
            // check there is enought nodes to reverse
            ListNode next = head; // next is not null
            for (int i = 0; i < k; i++) {
                if (next.next == null) {
                    return next;
                }
                next = next.next;
            }

            // reverse
            ListNode n1 = head.next;
            ListNode prev = head, curt = n1;
            for (int i = 0; i < k; i++) {
                ListNode temp = curt.next;
                curt.next = prev;
                prev = curt;
                curt = temp;
            }

            n1.next = curt;
            head.next = prev;
            return n1;
        }
    }
}
