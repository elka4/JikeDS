package DP.DP6;
import org.junit.Test;

public class DP_2String {
    //  Longest Common Subsequence
    //  9Ch DP
/*
    A=“jiuzhang”,
    B=“liji ang”
       j  i ang
    • 输出:5(最长公共子串是jiang )

    动态规划组成部分一:确定状态
    • 设A长度是m, B长度是n
    • 现在我们考虑最优策略产生出的最长公共子串(虽然还不知道是什么)
    • 最后一步:观察A[m-1]和B[n-1]这两个字符是否作为一个对子在最优策 略中

    情况一:对子中没有A[m-1]。     推论:A和B的最长公共子串就是A前m-1个字符和B前n个字符的最长公共子串
    情况二:对子中没有B[n-1]。     推论:A和B的最长公共子串就是A前m个字符和B前n-1个字符的最长公共子串
    情况三:对子中有A[m-1]-B[n-1]。推论:A和B的最长公共子串就是A前m-1个字符和B前n-1个字符的最长公共子串+A[m-1]
    -----------------------------------------------------------------------------------------------

    子问题：
    • 要求A[0..m-1]和B[0..n-2]的最长公共子串，A[0..m-2]和B[0..n-1]的最长
    公共子串和A[0..m-2]和B[0..n-2]的最长公共子串
    • 原来是求A[0..m-1]和B[0..n-1]的最长公共子串
    • 子问题
    • 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子串 的长度
    -----------------------------------------------------------------------------------------------
    动态规划组成部分二:转移方程

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子串的长度
    • 要求f[m][n]

    f[i][j] = max{f[i-1][j], f[i][j-1], f[i-1][j-1]+1|A[i-1]=B[j-1]}

    情况一:A[0..i-2]和B[0..j- 1]的最长公共子串；

    情况二:A[0..i-1]和 B[0..j-2]的最长公共子串

    情况三:A[0..i-2]和B[0..j-2]的最长 公共子串+A[i-1]
    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子串的长度
    • 转移方程:f[i][j] = max{f[i-1][j], f[i][j-1], f[i-1][j-1]+1|A[i-1]=B[j-1]}
    • 初始条件:空串和任何串的最长公共子串长度是0
        – f[0][j] = 0, j=0..n
        – f[i][0] = 0, i=0..m
    -----------------------------------------------------------------------------------------------
    动态规划组成部分四:计算顺序

    • f[0][0], f[0][1], ..., f[0][n]
    • f[1][0], f[1][1], ..., f[1][n]
    •...
    • f[m][0], f[m][1], ..., f[m][n]
    • 答案是f[m][n]
    • 时间复杂度(计算步数)O(MN)，空间复杂度(数组大小)O(MN) • 可以用滚动数组优化空间至O(N)
    -----------------------------------------------------------------------------------------------

 */

    public int longestCommonSubsequence1(String AA, String BB) {
        char[] A = AA.toCharArray();
        char[] B = BB.toCharArray();
        int m = A.length;
        int n = B.length;
        int[][] f = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                //init 默认就是0，做了这个只是逻辑更清晰
                if (i == 0 || j ==0) { f[i][j] = 0; continue; }

                // normal transiton function
                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);
                if (A[i - 1] == B[j - 1]) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
                }
            }
        }
        return f[m][n];
    }

    @Test
    public void test01() {
    /*
    For "ABCD" and "EDCA", the LCS is "A" (or "D", "C"), return 1.
    For "ABCD" and "EACB", the LCS is "AC", return 2.
    */
        System.out.println(longestCommonSubsequence1("ABCD", "EDCA"));
        System.out.println(longestCommonSubsequence1("ABCD" , "EACB"));
    }

/////////////////////////////////////////////////////////////////////////////////////////////
    //  97. Interleaving String
    //  mine
    //  determine whether s3 is formed by the interleaving of s1 and s2.

/*
    LintCode 29 Interleaving String

    • 题意:
    • 给定三个字符串A, B, X
    • 判断X是否是由A, B交错在一起形成
    – 即A是X的子序列，去掉A后，剩下的字符组成B
    • 例子:
    • 输入:A=“aabcc” B=“dbbac”, X=“aadbbcbcac” • 输出:True( X=“aadbbcbcac” )

    -----------------------------------------------------------------------------------------------

    动态规划组成部分一:确定状态

    • 首先，如果X的长度不等于A的长度+B的长度，直接输出False
    • 设A长度是m, B长度是n，X的长度是m+n
    • 最后一步:假设X是由A和B交错形成的，那么X的最后一个字符X[m+n-1]
    – 要么是A[m-1]
    • 那么X[0..m+n-2]是由A[0..m-2]和B[0..n-1]交错形成的
    – 要么是B[n-1]
    • 那么X[0..m+n-2]是由A[0..m-1]和B[0..n-2]交错形成的

    -----------------------------------------------------------------------------------------------

    子问题

    • 要求X[0..m+n-1]是否由A[0..m-1]和B[0..n-1]交错形成
    • 需要知道X[0..m+n-2]是否由A[0..m-2]和B[0..n-1]交错形成，以及 X[0..m+n-2]是否由A[0..m-1]和B[0..n-2]交错形成
    • 子问题
    • 状态:设f[s][i][j]为X前s个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成
    • 但是s=i+j，所以可以简化为:设f[i][j]为X前i+j个字符是否由A前i个字符 A[0..i-1]和B前j个字符B[0..j-1]交错形成

    -----------------------------------------------------------------------------------------------

    动态规划组成部分二:转移方程

    • 设f[i][j]为X前i+j个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成
    f[i][j] = (f[i-1][j] AND X[i+j-1]==A[i-1]) OR (f[i][j-1] AND X[i+j-1]==B[j-1])

    f[i][j]                         : X前i+j个字符是否由A 前i个字符和B前j个字 符交错形成
    f[i-1][j] AND X[i+j-1]==A[i-1]  : 情况一:X前i+j-1个字符由A前i-1 个字符和B前j个字符交错形成, X 第i+j个字符等于A第i个字符
    f[i][j-1] AND X[i+j-1]==B[j-1]  : 情况二:X前i+j-1个字符由A前i个 字符和B前j-1个字符交错形成, X第 i+j个字符等于B第j个字符


    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • 设f[i][j]为X前i+j个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成
    • 转移方程
        – f[i][j] = (f[i-1][j] AND X[i+j-1]==A[i-1]) OR (f[i][j-1] AND X[i+j-1]==B[j-1])
    • 初始条件:空串由A的空串和B的空串交错形成àf[0][0] = True
    • 边界情况:如果i=0，不考虑情况一;如果j=0，不考虑情况二

    -----------------------------------------------------------------------------------------------

    动态规划组成部分四:计算顺序

    • f[0][0], f[0][1], ..., f[0][n]
    • f[1][0], f[1][1], ..., f[1][n] •...
    • f[m][0], f[m][1], ..., f[m][n]
    • 答案是f[m][n]
    • 时间复杂度(计算步数)O(MN)，空间复杂度(数组大小)O(MN)，可 以用滚动数组优化空间至O(N)
    -----------------------------------------------------------------------------------------------
*/

    public boolean isInterleave11(String s1, String s2, String s3) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        char[] c3 = s3.toCharArray();
        int m = c1.length;
        int n = c2.length;
        if (c3.length != m + n) { return false; }
        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i > 0 && c3[i + j - 1] == c1[i - 1]) {
                    f[i][j] = f[i][j] | f[i - 1][j];
                }

                if (j > 0 && c3[i + j - 1] == c2[j - 1]) {
                    f[i][j] = f[i][j] | f[i][j - 1];
                }
            }
        }
        return f[m][n];
    }

    @Test
    public void test02() {
        /*
        For s1 = "aabcc", s2 = "dbbca"
        When s3 = "aadbbcbcac", return true.
        When s3 = "aadbbbaccc", return false.
         */
        System.out.println(isInterleave11("aabcc", "dbbca", "aadbbcbcac"));
        System.out.println(isInterleave11("aabcc", "dbbca", "aadbbbaccc"));
    }

/////////////////////////////////////////////////////////////////////////////////////////////
    //  72. Edit Distance
    //  9Ch DP 动态规划版本去掉注释
    //  find the minimum number of steps required to convert word1 to word2.

    /*
    • 给定两个字符串A，B
    • 要求把A变成B，每次可以进行下面一种操作:  – 增加一个字符 – 去掉一个字符 – 替换一个字符
    • 最少需要多少次操作，即最小编辑距离
    • 输入:A=“mart”, B=“karma”        • 输出:3 (m换成k，t换成m，加上a)

    -----------------------------------------------------------------------------------------------
    动态规划组成部分一:确定状态

    • 设A长度是m, B长度是n
    • 全部操作完成后A的长度也是n，并且A[n-1]=B[n-1]
    • 于是最优策略(以及所有合法策略)最终都是让A的最后一个字符变成B 的最后一个字符

    情况一:A在最后插入B[n-1]        • 要将A[0..m-1]变成B[0..n-2]
    情况二:A最后一个字符替换成B[n-1] • 要将A[0..m-2]变成B[0..n-2]
    情况三:A删掉最后一个字符         • 要将A[0..m-2]变成B[0..n-1]
    情况四:A和B最后一个字符相等      • 要将A[0..m-2]变成B[0..n-2]

    -----------------------------------------------------------------------------------------------
    子问题

    • 要求A[0..m-1]和B[0..n-2]的最小编辑距离，A[0..m-2]和B[0..n-1]的最小编辑距离和A[0..m-2]和B[0..n-2]的最小编辑距离
    • 原来是求A[0..m-1]和B[0..n-1]的最小编辑距离
    • 子问题
    • 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]的最小编辑距离
    -----------------------------------------------------------------------------------------------
    动态规划组成部分二:转移方程

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]的最小编辑距离
    • 要求f[m][n]
    f[i][j] = min{f[i][j-1]+1, f[i-1][j-1]+1, f[i-1][j]+1, f[i-1][j-1]|A[i-1]=B[j-1]}
    f[i][j-1]+1   情况一:A在最后插入 B[j-1]
    f[i-1][j-1]+1 情况二:A最后一个字符 替换成B[j-1]
    f[i-1][j]+1   情况三:A删掉最后一个 字符
    f[i-1][j-1]   情况四:A和B最后一个 字符相等
    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]的最小编辑距离
    • 转移方程: f[i][j] = min{f[i][j-1]+1, f[i-1][j-1]+1, f[i-1][j]+1, f[i-1][j-1]|A[i- 1]=B[j-1]}
    • 初始条件:一个空串和一个长度为L的串的最小编辑距离是L
        – f[0][j] = j (j = 0, 1, 2, ..., n)
        – f[i][0] = i (i = 0, 1, 2, ..., m)
 */
    public int minDistance(String word1, String word2) {
        char[] s1 = word1.toCharArray();
        char[] s2 = word2.toCharArray();
        int m = s1.length;
        int n = s2.length;
        int[][] f = new int[m + 1][n + 1];

        for (int i = 0; i <= m; ++i) {
            for (int j = 0; j <= n; ++j) {
                if (i == 0) {f[i][j] = j; continue;}
                if (j == 0) {f[i][j] = i; continue;}
                //                            delete        insert         replace
                f[i][j] = Math.min(Math.min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1;

                if (s1[i - 1] == s2[j - 1]) {
                    f[i][j] = Math.min(f[i][j], f[i - 1][j - 1]);
                }
            }
        }
        return f[m][n];
    }

    @Test
    public void test03() {
        //Given word1 = "mart" and word2 = "karma", return 3.
        System.out.println(minDistance("mart", "karma"));
    }


/////////////////////////////////////////////////////////////////////////////////////////////
    //  115. Distinct Subsequences
    //  9Ch DP
    //  Implement regular expression matching with support for '.' and '*'.

/*
    • 给定两个字符串A[0..m-1]，B[0..n-1] • 问B在A中出现多少次(可以不连续)
    • 输入:A=“rabbbit”, B=“rabbit”  • 输出:3  – rabbbit – rabbbit – rabbbit
    -----------------------------------------------------------------------------------------------
    题目分析
    • 双序列型动态规划
    • B在A中出现多少次(可以不连续)
    • 如果至少出现一次，那么A和B的最长公共子串就是B，而且也不能更长
    • 用最长公共子串的思路:对应对子
    • 但不同的是，B的每一个字符都必须出现在一个对子里
    • 所以这题的“最后一步”以B为出发点
    -----------------------------------------------------------------------------------------------
    动态规划组成部分一:确定状态

    情况1:B[n-1] = A[m-1]，结成对子    求B[0..n-2]在A[0..m-2]中出现多少次
    情况2:B[n-1]不和 A[m-1]结成对子    求B[0..n-1]在A[0..m-2]中出现多少次

    -----------------------------------------------------------------------------------------------
    子问题

    • 要求B[0..n-1]在A[0..m-1]中出现多少次
    • 需要知道B[0..n-1]在A[0..m-2]中出现多少次，以及B[0..n-2]在A[0..m-2] 中出现多少次
    • 子问题
    • 状态:设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次
    -----------------------------------------------------------------------------------------------
    动态规划组成部分二:转移方程

    • 设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次
    • 要求f[m][n]
    f[i][j] = f[i-1][j-1]|A[i-1]=B[j-1] + f[i-1][j]

    f[i-1][j-1]|A[i-1]=B[j-1]  情况1:B[j-1] = A[i-1]，结成对子
    f[i-1][j]                  情况2:B[j-1]不和 A[i-1]结成对子
    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • 设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次
    • 转移方程: f[i][j] = f[i-1][j-1]|A[i-1]=B[j-1] + f[i-1][j]
    • 初始条件:
        – 如果B是空串，B在A中出现次数是1
        – f[i][0] = 1 (i = 0, 1, 2, ..., m)
        – 如果A是空串而B不是空串，B在A中出现次数是0
        – f[0][j] = 0 (j = 1, 2, ..., n)
    -----------------------------------------------------------------------------------------------
 */
    public int numDistinct(String s, String t) {
        char[] c1 = s.toCharArray();
        char[] c2 = t.toCharArray();
        int m = c1.length;
        int n = c2.length;
        int[][] f = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                //s2 is empty //f[i][j] = 1; very important
                if (j == 0) { f[i][j] = 1; continue; }
                // s1 is empty, s2 is NOT empty
                if (i == 0) { f[i][j] = 0; continue; }

                f[i][j] = f[i - 1][j];
                if (c1[i - 1] == c2[j - 1]) {
                    f[i][j] += f[i - 1][j - 1];
                }
            }
        }
        return f[m][n];
    }
    @Test
    public void test04() {
        //Given S = "rabbbit", T = "rabbit", return 3.
        System.out.println(numDistinct("rabbbit", "rabbit"));
    }//3

/////////////////////////////////////////////////////////////////////////////////////////////
    //  10. Regular Expression Matching
    //  9CH DP
    //  Implement regular expression matching with support for '.' and '*'.

    /*
    LintCode 154 Regular Expression Matching

    • 题意:
    • 给定两个字符串A，B
    • B是一个正则表达式，里面可能含有‘.’和‘*’
    – ‘.’ 可以匹配任何单个字符
    – ‘*’ 可以匹配0个或多个前一个字符 • 问A和B是否匹配
    • 例子:
    – isMatch("aa","a") → false
    – isMatch("aa","aa") → true
    – isMatch("aaa","aa") → false
    – isMatch("aa", "a*") → true
    – isMatch("aa", ".*") → true
    – isMatch("ab", ".*") → true
    – isMatch("aab", "c*a*b") → true
    -----------------------------------------------------------------------------------------------
    动态规划组成部分一:确定状态

    • 双序列型动态规划
    • 设A长度是m, B长度是n
    • 现在我们考虑A和B如何匹配
    • 最后一步:关注最后的字符
    • 主要取决于正则表达式B中最后的字符B[n-1]是什么

    • 如果B[n-1]是一个正常字符(非.非*)，则如果A[m-1]=B[n-1]，能否匹配
    取决于A[0..m-2]和B[0..n-2]是否匹配;否则不能匹配
    • 如果B[n-1]是’.’，则A[m-1]一定是和’.’匹配，之后能否匹配取决于A[0..m-2]
    和B[0..n-2]是否匹配
    • 如果B[n-1]是’*’，它代表B[n-2]=c可以重复0次或多次，它们是一个整体c*，
    需要考虑A[m-1]是0个c，还是多个c中的最后一个
        – A[m-1]是0个c，能否匹配取决于A[0..m-1]和B[0..n-3]是否匹配
        – A[m-1]是多个c中的最后一个，能否匹配取决于A[0..m-2]和B[0..n-1]是否匹配 • 这种情况必须A[m-1]=c或者c=‘.’
    • 要求A前m个字符和B前n个字符能否匹配，需要知道A前m个字符和B前 n-1个字符，
    A前m-1个字符和B前n个字符以及A前m个字符和B前n-2个 字符能否匹配
    • 子问题
    • 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配
    -----------------------------------------------------------------------------------------------
    动态规划组成部分二:转移方程

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配

    f[i][j] = f[i-1][j-1]，如果B[j-1]=‘.’或者A[i-1]=B[j-1]

    f[i][j] = f[i][j-2] OR (f[i-1][j] AND (B[j-2]=‘.’ OR B[j-2]=A[i-1]))，如果B[j-1]=‘*’
    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配
    • 空串和空正则表达式匹配:f[0][0] = TRUE • 空的正则表达式不能匹配长度>0的串
        – f[1][0] = ... = f[m][0] = FALSE
    • 注意:f[0][1..n]也用动态规划计算，但是因为没有A[-1]，所以只能用第 二种情况中的f[i][j-2]
    -----------------------------------------------------------------------------------------------
    动态规划组成部分四:计算顺序

    • f[0][0], f[0][1], ..., f[0][n]
    • f[1][0], f[1][1], ..., f[1][n]
    •...
    • f[m][0], f[m][1], ..., f[m][n]
    • 答案是f[m][n]
    • 时间复杂度(计算步数)O(MN)，空间复杂度(数组大小)O(MN)
    • 可以用滚动数组优化空间至O(N)
    -----------------------------------------------------------------------------------------------
     */
    public boolean isMatch1(String s, String p) {
        char[] c1 = s.toCharArray();
        char[] c2 = p.toCharArray();
        int m = c1.length;
        int n = c2.length;
        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;

        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (c2[j - 1] != '*') {
                    if (i > 0 && (c2[j - 1] == '.' || c1[i - 1] == c2[j - 1]))
                        f[i][j] = f[i - 1][j - 1];
                } else {                            // c2[j - 1] == '*'
                    if (j - 2 >= 0)
                        f[i][j] |= f[i][j - 2];
                    if (i >= 1 && j >= 2) {
                        if (c2[j - 2] == '.' || c2[j - 2] == c1[i - 1])
                            f[i][j] |= f[i - 1][j];
                    }
                }
            }
        }
        return  f[m][n];
    }

    @Test
    public void test05() {
        //isMatch("aa","a") → false
        //isMatch("aa","aa") → true
        //isMatch("aaa","aa") → false
        //isMatch("aa", "a*") → true
        //isMatch("aa", ".*") → true
        //isMatch("ab", ".*") → true
        //isMatch("aab", "c*a*b") → true
        System.out.println(isMatch1("aab", "c*a*b"));
    }

/////////////////////////////////////////////////////////////////////////////////////////////
    //  44. Wildcard Matching
    //  Java DP Accepted

    /*
    -----------------------------------------------------------------------------------------------
    LintCode 192 Wildcard Matching

    • 题意:
    • 给定两个字符串A，B
    • B是一个正则表达式，里面可能含有’?’和’*’
    – ‘?’ 可以匹配任何单个字符
    – ‘*’ 可以匹配0个或多个任意字符 • 问A和B是否匹配
    • 例子:
    – isMatch("aa","a") → false
    – isMatch("aa","aa") → true
    – isMatch("aaa","aa") → false
    – isMatch("aa", "*") → true
    – isMatch("aa", "a*") → true
    – isMatch("ab", "?*") → true
    – isMatch("aab", "c*a*b") → false
    -----------------------------------------------------------------------------------------------
    动态规划组成部分一:确定状态

    • 双序列型动态规划
    • 和Regular Expression Matching很类似，因为’.’和’?’作用相同，但是这 题中’*’可以匹配0个或多个任意字符
    • 设A长度是m, B长度是n
    • 现在我们考虑A和B如何匹配
    • 关注最后的字符
    • 主要取决于Wildcard中B[n-1]是什么

    • 如果B[n-1]是一个正常字符(非?非*)，则如果A[m-1]=B[n-1]，能否匹
    配取决于A[0..m-2]和B[0..n-2]是否匹配;否则不能匹配
    • 如果B[n-1]是’?’，则A[m-1]一定是和’?’匹配，之后能否匹配取决于
    A[0..m-2]和B[0..n-2]是否匹配
    • 如果B[n-1]是’*’，它可以匹配0个或任意多个字符，需要考虑A[m-1]有没
    有被这个*匹配
    – A[m-1]不被‘*’匹配，能否匹配取决于A[0..m-1]和B[0..n-2]是否匹配 – A[m-1]被‘*’匹配，
    能否匹配取决于A[0..m-2]和B[0..n-1]是否匹配

    -----------------------------------------------------------------------------------------------
    子问题
    • 要求A前m个字符和B前n个字符能否匹配，需要知道A前m-1个字符和B 前n-1个字符，
    A前m个字符和B前n-1个字符以及A前m-1个字符和B前n 个字符能否匹配
    • 子问题
    • 状态:设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配
    -----------------------------------------------------------------------------------------------
    动态规划组成部分二:转移方程

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配

    f[i][j] = f[i-1][j-1]，如果B[j-1]=‘?’或者A[i-1]=B[j-1]

    f[i][j] = f[i-1][j] OR f[i][j-1]，如果B[j-1]=‘*’
    -----------------------------------------------------------------------------------------------
    动态规划组成部分三:初始条件和边界情况

    • 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配
    • 空串和空Wildcard匹配:f[0][0] = TRUE • 空的Wildcard不能匹配长度>0的串
        – f[1][0] = ... = f[m][0] = FALSE
    • f[0][1..n]也用动态规划计算，但是因为没有A[-1]，所以只能用第二种情 况中的f[i][j-1]
    -----------------------------------------------------------------------------------------------
    动态规划组成部分四:计算顺序

    • f[0][0], f[0][1], ..., f[0][n]
    • f[1][0], f[1][1], ..., f[1][n]
    •...
    • f[m][0], f[m][1], ..., f[m][n]
    • 答案是f[m][n]
    • 时间复杂度(计算步数)O(MN)，空间复杂度(数组大小)O(MN)
    • 可以用滚动数组优化空间至O(N)
    -----------------------------------------------------------------------------------------------
 */
    public boolean isMatch2(String s, String p) {
        int m = s.length(), n = p.length();
        char[] ws = s.toCharArray();
        char[] wp = p.toCharArray();
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;

        for (int j = 1; j <= n; j++)
            dp[0][j] = dp[0][j - 1] && wp[j - 1] == '*';

        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 0) {
                    dp[0][j] = dp[0][j - 1] && wp[j - 1] == '*';
                    continue;
                }
                if (wp[j - 1] == '?' || ws[i - 1] == wp[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else if (wp[j - 1] == '*')
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
            }
        }
        return dp[m][n];
    }

    @Test
    public void test06() {
        //isMatch("aa","a") → false
        //isMatch("aa","aa") → true
        //isMatch("aaa","aa") → false
        //isMatch("aa", "*") → true
        //isMatch("aa", "a*") → true
        //isMatch("ab", "?*") → true
        //isMatch("aab", "c*a*b") → false
        System.out.println(isMatch2("aab", "?*"));
    }


/////////////////////////////////////////////////////////////////////////////////////////////
    //find the maximum number of strings that you can form with given m 0s and n 1s.
    // Each 0 and 1 can be used at most once.
    //  474. Ones and Zeroes


    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for (String s : strs) {
            int[] cost = count(s);
            for (int i = m; i >= cost[0]; i--)
                for (int j = n; j >= cost[1]; j--)
                    dp[i][j] = Math.max(dp[i][j], dp[i - cost[0]][j - cost[1]] + 1);
        }
        return dp[m][n];
    }

    public int[] count(String str) {
        int[] cost = new int[2];
        for (int i = 0; i < str.length(); i++)
            cost[str.charAt(i) - '0']++;
        return cost;
    }

    @Test
    public void test07() {
        /*
        Example 1:
        Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
        Output: 4  “10,”0001”,”1”,”0”

        Example 2:
        Input: Array = {"10", "0", "1"}, m = 1, n = 1
        Output: 2
        */
        System.out.println(findMaxForm(new String[]{"10", "0001", "111001", "1", "0"}, 5, 3));
        System.out.println(findMaxForm(new String[]{"10", "0", "1"}, 1, 1));
    }

/////////////////////////////////////////////////////////////////////////////////////////////
}
