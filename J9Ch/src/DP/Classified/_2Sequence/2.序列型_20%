• 序列型动态规划
_2PaintHouse    09:09

序列+位操作型动态规划
_7CountingBits  01:41:20

• 需要辅助数据结构/算法(字母树，哈希表，二分查找)的动态规划
序列+哈希表
_3FrogJump  01:30:58


• 有状态的序列型动态规划
_1PaintHouseII  01:39
_2HouseRobber   18:58
_3HouseRobberII 27:11
_6BestTimeToBuyAndSellStockIII  31:38
_7BestTimeToBuyAndSellStockIV   01:17:13

• 最长序列型动态规划
_8LongestIncreasingSubsequence 01:35:35
_9RussianDollEnvelopes  01:44:58


• 双序列型动态规划
_1LongestCommonSubsequence  02:45
_2InterleavingString    25:53
_3EditDistance  37:00
_4DistinctSubsequences  55:50
_5RegularExpressionMatching 01:08:08
_6WildcardMatching  01:26:57
_7OnesandZeroes 01:39:55

////////////////////////////////////////////////////////////////////////

• 序列型动态规划:...前i个...最小/方式数/可行性

• 有状态的序列型动态规划
• 最长序列型动态规划

////////////////////////////////////////////////////////////////////////


序列型动态规划
• 给定一个序列
• 动态规划方程f[i]中的下标i表示前i个元素a[0], a[1], ..., a[i-1]的某种性质
    – 坐标型的f[i]表示以ai为结尾的某种性质
• 初始化中，f[0]表示空序列的性质
    – 坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质

序列+状态型动态规划小结:
• 当思考动态规划最后一步时，这一步的选择依赖于前一步的某种状态
• 初始化时，f[0]代表前0个元素/前0天的情况 – 与坐标型动态规划区别
• 计算时，f[i]代表前i个元素(即元素0~i-1)的某种性质


最长序列型动态规划:
• 题目给定一个序列
• 要求找出符合条件的最长子序列
• 方法
    – 记录以每个元素i结尾的最长子序列的长度
    – 计算时，在i之前枚举子序列上一个元素是哪个


////////////////////////////////////////////////////////////////////////

双序列型动态规划总结
• 两个一维序列/字符串
• 突破口
    – 串A和串B的最后一个字符是否匹配
    – 是否需要串A/串B的最后一个字符
    – 缩减问题规模
• 数组下标表示序列A前i个，序列B前j个: f[i][j]
• 初始条件和边界情况
    – 空串如何处理
    – 计数型(情况1+情况2+...)以及最值型(min/max{情况1，情况2，...})
• 匹配的情况下勿忘+1(操作数多1次，匹配长度多1)
