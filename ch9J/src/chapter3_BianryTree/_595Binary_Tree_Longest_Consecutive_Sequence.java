package ch9J.chapter3_BianryTree;

/**
 * Created by tzh on 3/2/17.
 */
public class _595Binary_Tree_Longest_Consecutive_Sequence {
    // version 1: Traverse + Divide Conquer
    public class Solution1 {
        /**
         * @param root the root of binary tree
         * @return the length of the longest consecutive sequence path
         */
        public int longestConsecutive(TreeNode root) {
            return helper(root, null, 0);
        }

        private int helper(TreeNode root, TreeNode parent, int lengthWithoutRoot) {
            if (root == null) {
                return 0;
            }

            int length = (parent != null && parent.val + 1 == root.val)
                    ? lengthWithoutRoot + 1
                    : 1;
            int left = helper(root.left, root, length);
            int right = helper(root.right, root, length);
            return Math.max(length, Math.max(left, right));
        }
    }

    // version 2: Another Traverse + Divide Conquer
    public class Solution2 {
        private int longest;

        /**
         * @param root the root of binary tree
         * @return the length of the longest consecutive sequence path
         */
        public int longestConsecutive(TreeNode root) {
            longest = 0;
            helper(root);
            return longest;
        }

        private int helper(TreeNode root) {
            if (root == null) {
                return 0;
            }

            int left = helper(root.left);
            int right = helper(root.right);

            int subtreeLongest = 1; // at least we have root
            if (root.left != null && root.val + 1 == root.left.val) {
                subtreeLongest = Math.max(subtreeLongest, left + 1);
            }
            if (root.right != null && root.val + 1 == root.right.val) {
                subtreeLongest = Math.max(subtreeLongest, right + 1);
            }

            if (subtreeLongest > longest) {
                longest = subtreeLongest;
            }
            return subtreeLongest;
        }
    }

    // version 3: Divide Conquer
    public class Solution3 {
        private class ResultType {
            int maxInSubtree;
            int maxFromRoot;
            public ResultType(int maxInSubtree, int maxFromRoot) {
                this.maxInSubtree = maxInSubtree;
                this.maxFromRoot = maxFromRoot;
            }
        }
        /**
         * @param root the root of binary tree
         * @return the length of the longest consecutive sequence path
         */
        public int longestConsecutive(TreeNode root) {
            return helper(root).maxInSubtree;
        }

        private ResultType helper(TreeNode root) {
            if (root == null) {
                return new ResultType(0, 0);
            }

            ResultType left = helper(root.left);
            ResultType right = helper(root.right);

            // 1 is the root itself.
            ResultType result = new ResultType(0, 1);

            if (root.left != null && root.val + 1 == root.left.val) {
                result.maxFromRoot = Math.max(
                        result.maxFromRoot,
                        left.maxFromRoot + 1
                );
            }

            if (root.right != null && root.val + 1 == root.right.val) {
                result.maxFromRoot = Math.max(
                        result.maxFromRoot,
                        right.maxFromRoot + 1
                );
            }

            result.maxInSubtree = Math.max(
                    result.maxFromRoot,
                    Math.max(left.maxInSubtree, right.maxInSubtree)
            );

            return result;
        }
    }
}
